<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tradutor de Mangá V4.0</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
    .container { max-width: 800px; margin: 0 auto; }
    .header { text-align: center; color: white; margin-bottom: 30px; }
    .header h1 { font-size: 32px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
    .version { background: rgba(255,255,255,0.3); padding: 8px 20px; border-radius: 20px; font-size: 14px; display: inline-block; font-weight: bold; margin-top: 10px; }
    .card { background: white; border-radius: 16px; padding: 25px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); margin-bottom: 20px; }
    .settings { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px; }
    .setting-box { padding: 15px; background: #f9fafb; border-radius: 10px; }
    .setting-box label { display: block; font-size: 13px; font-weight: bold; margin-bottom: 8px; }
    .setting-box select { width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 6px; font-size: 14px; }
    .upload-btn { width: 100%; padding: 50px 20px; background: linear-gradient(135deg, #667eea, #764ba2); border: none; border-radius: 12px; color: white; font-size: 18px; font-weight: bold; cursor: pointer; text-align: center; }
    .upload-btn:hover { transform: translateY(-3px); }
    .icon { font-size: 48px; display: block; margin-bottom: 15px; }
    input[type="file"] { display: none; }
    .preview { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px; margin-top: 20px; }
    .preview-item { position: relative; border-radius: 10px; overflow: hidden; border: 3px solid #e5e7eb; }
    .preview-item img { width: 100%; height: 150px; object-fit: cover; }
    .remove { position: absolute; top: 8px; right: 8px; background: #ef4444; color: white; border: none; width: 30px; height: 30px; border-radius: 50%; cursor: pointer; font-size: 18px; }
    .btn { width: 100%; padding: 15px; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; margin-top: 15px; }
    .btn-primary { background: linear-gradient(135deg, #667eea, #764ba2); color: white; }
    .btn-success { background: #10b981; color: white; }
    .btn-secondary { background: #6b7280; color: white; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .progress { margin-top: 20px; }
    .progress-bar { width: 100%; height: 10px; background: #e5e7eb; border-radius: 5px; overflow: hidden; margin-bottom: 10px; }
    .progress-fill { height: 100%; background: linear-gradient(90deg, #667eea, #764ba2); width: 0%; transition: width 0.3s; }
    .progress-text { text-align: center; font-size: 14px; color: #666; }
    .result-img { width: 100%; border-radius: 10px; margin-bottom: 15px; border: 2px solid #e5e7eb; }
    .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .alert { padding: 15px; border-radius: 10px; margin-top: 15px; font-size: 14px; }
    .alert-error { background: #fee2e2; color: #991b1b; border: 2px solid #fca5a5; }
    .alert-info { background: #dbeafe; color: #1e40af; border: 2px solid #93c5fd; }
    .hidden { display: none; }
    .stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 20px; }
    .stat { text-align: center; padding: 15px; background: #f9fafb; border-radius: 8px; }
    .stat-num { font-size: 28px; font-weight: bold; color: #667eea; }
    .stat-label { font-size: 12px; color: #666; margin-top: 5px; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>🌐 Tradutor de Mangá PRO</h1>
      <div class="version">⚡ V4.2 - AGRUPAMENTO BALANCEADO</div>
    </div>

    <div class="card">
      <div class="settings">
        <div class="setting-box">
          <label>🗣️ De</label>
          <select id="from">
            <option value="eng">🇺🇸 Inglês</option>
            <option value="por">🇧🇷 Português</option>
            <option value="spa">🇪🇸 Espanhol</option>
          </select>
        </div>
        <div class="setting-box">
          <label>🎯 Para</label>
          <select id="to">
            <option value="pt">🇧🇷 Português</option>
            <option value="en">🇺🇸 Inglês</option>
            <option value="es">🇪🇸 Espanhol</option>
          </select>
        </div>
      </div>

      <button class="upload-btn" id="upload">
        <span class="icon">📤</span>
        <div>CLIQUE PARA ESCOLHER</div>
        <div style="font-size: 14px; margin-top: 10px; opacity: 0.9;">Até 2 imagens</div>
      </button>
      <input type="file" id="file" accept="image/*" multiple>
      
      <div id="prev" class="hidden">
        <h3 style="margin-top: 20px;">📸 Imagens:</h3>
        <div id="grid" class="preview"></div>
        <button class="btn btn-primary" id="go">🚀 TRADUZIR</button>
      </div>

      <div id="prog" class="hidden progress">
        <div class="progress-bar"><div class="progress-fill" id="fill"></div></div>
        <div class="progress-text" id="text">Processando...</div>
      </div>
    </div>

    <div id="results" class="card hidden">
      <h3 style="text-align: center; color: #10b981; margin-bottom: 20px;">✅ Concluído!</h3>
      <div class="stats">
        <div class="stat"><div class="stat-num" id="sb">0</div><div class="stat-label">Balões</div></div>
        <div class="stat"><div class="stat-num" id="st">0</div><div class="stat-label">Traduções</div></div>
        <div class="stat"><div class="stat-num" id="si">0</div><div class="stat-label">Imagens</div></div>
      </div>
      <div id="out"></div>
      <div class="btn-group">
        <button class="btn btn-success" id="dl">💾 Baixar</button>
        <button class="btn btn-secondary" id="new">🔄 Nova</button>
      </div>
    </div>

    <div class="alert alert-info">
      <strong>💡 V4.2 - Agrupamento Balanceado:</strong><br>
      ✅ Distância: 150px (nem muito, nem pouco)<br>
      ✅ Agrupa mesma linha (distância Y < 25px)<br>
      ✅ Limite de tamanho: máx 600x400px (evita grupos gigantes)<br>
      ✅ Ignora letras soltas (mín. 3 caracteres)
    </div>
    <div id="err" class="alert alert-error hidden"></div>
  </div>

  <script>
    const upload = document.getElementById('upload');
    const file = document.getElementById('file');
    const prev = document.getElementById('prev');
    const grid = document.getElementById('grid');
    const go = document.getElementById('go');
    const prog = document.getElementById('prog');
    const fill = document.getElementById('fill');
    const text = document.getElementById('text');
    const results = document.getElementById('results');
    const out = document.getElementById('out');
    const sb = document.getElementById('sb');
    const st = document.getElementById('st');
    const si = document.getElementById('si');
    const dl = document.getElementById('dl');
    const newBtn = document.getElementById('new');
    const from = document.getElementById('from');
    const to = document.getElementById('to');
    const err = document.getElementById('err');

    let files = [];
    let imgs = [];
    let tb = 0;
    let tt = 0;

    upload.onclick = () => file.click();

    file.onchange = e => {
      const f = Array.from(e.target.files);
      if (f.length === 0) return showErr('Nenhum arquivo!');
      if (f.length > 2) return showErr('Máximo 2 imagens!');
      files = f;
      showPreview();
      hideErr();
    };

    function showPreview() {
      grid.innerHTML = '';
      prev.classList.remove('hidden');
      files.forEach((f, i) => {
        const r = new FileReader();
        r.onload = e => {
          const d = document.createElement('div');
          d.className = 'preview-item';
          d.innerHTML = '<img src="' + e.target.result + '"><button class="remove" onclick="removeImg(' + i + ')">×</button>';
          grid.appendChild(d);
        };
        r.readAsDataURL(f);
      });
    }

    window.removeImg = i => {
      files.splice(i, 1);
      files.length === 0 ? (prev.classList.add('hidden'), file.value = '') : showPreview();
    };

    go.onclick = async () => {
      go.disabled = true;
      prog.classList.remove('hidden');
      results.classList.add('hidden');
      imgs = [];
      tb = 0;
      tt = 0;

      try {
        for (let i = 0; i < files.length; i++) {
          upd(i, files.length, 'Processando ' + (i + 1) + '/' + files.length);
          const r = await proc(files[i], i + 1);
          imgs.push(r);
        }
        upd(files.length, files.length, 'Concluído!');
        showRes();
      } catch (error) {
        showErr('Erro: ' + error.message);
        go.disabled = false;
        prog.classList.add('hidden');
      }
    };

    async function proc(f, n) {
      return new Promise((res, rej) => {
        const r = new FileReader();
        r.onload = async e => {
          const img = new Image();
          img.onload = async () => {
            const c = document.createElement('canvas');
            const ctx = c.getContext('2d');
            c.width = img.width;
            c.height = img.height;
            ctx.drawImage(img, 0, 0);

            upd(null, null, '🔍 OCR ' + n + '...');

            try {
              const ocr = await Tesseract.recognize(c, from.value, {
                logger: m => m.status === 'recognizing text' && upd(null, null, 'OCR: ' + Math.round(m.progress * 100) + '%')
              });

              // FILTROS RIGOROSOS
              const words = ocr.data.words.filter(w => 
                w.confidence > 50 && 
                w.text.trim().length >= 3 && // MÍNIMO 3 CARACTERES
                /[a-zA-Z]{2,}/.test(w.text) // DEVE TER PELO MENOS 2 LETRAS SEGUIDAS
              );

              console.log('Palavras válidas:', words.length);

              const groups = group(words, 150); // DISTÂNCIA BALANCEADA = 150px
              console.log('Balões:', groups.length);
              
              tb += groups.length;

              for (let i = 0; i < groups.length; i++) {
                const g = groups[i];
                upd(null, null, '🌐 Balão ' + (i + 1) + '/' + groups.length);
                
                const txt = g.words.map(w => w.text).join(' ');
                const trans = await translate(txt);
                tt++;

                draw(ctx, g.bbox, trans);
              }

              res(c.toDataURL('image/png'));
            } catch (e) {
              rej(new Error('Falha OCR'));
            }
          };
          img.onerror = () => rej(new Error('Erro carregar'));
          img.src = e.target.result;
        };
        r.onerror = () => rej(new Error('Erro ler'));
        r.readAsDataURL(f);
      });
    }

    function group(words, maxDist) {
      if (words.length === 0) return [];
      
      const grps = [];
      const used = new Set();

      // Ordenar palavras por posição
      const sorted = [...words].sort((a, b) => {
        const yDiff = a.bbox.y0 - b.bbox.y0;
        if (Math.abs(yDiff) > 50) return yDiff;
        return a.bbox.x0 - b.bbox.x0;
      });

      sorted.forEach((w, i) => {
        if (used.has(i)) return;
        
        const g = {
          words: [w],
          bbox: { ...w.bbox }
        };
        used.add(i);

        // Primeira passada: buscar palavras MUITO próximas
        sorted.forEach((o, j) => {
          if (i === j || used.has(j)) return;
          
          const dx = (w.bbox.x0 + w.bbox.x1)/2 - (o.bbox.x0 + o.bbox.x1)/2;
          const dy = (w.bbox.y0 + w.bbox.y1)/2 - (o.bbox.y0 + o.bbox.y1)/2;
          const dist = Math.sqrt(dx*dx + dy*dy);

          // Só agrupar se REALMENTE próximo
          const sameLine = Math.abs(dy) < 25 && Math.abs(dx) < maxDist;
          const veryClose = dist < maxDist * 0.6; // 60% da distância máxima

          if (sameLine || veryClose) {
            // Verificar se o grupo não está ficando grande demais
            const newWidth = Math.max(g.bbox.x1, o.bbox.x1) - Math.min(g.bbox.x0, o.bbox.x0);
            const newHeight = Math.max(g.bbox.y1, o.bbox.y1) - Math.min(g.bbox.y0, o.bbox.y0);
            
            // Limitar tamanho do grupo (evitar balões gigantes)
            if (newWidth < 600 && newHeight < 400) {
              g.words.push(o);
              g.bbox.x0 = Math.min(g.bbox.x0, o.bbox.x0);
              g.bbox.y0 = Math.min(g.bbox.y0, o.bbox.y0);
              g.bbox.x1 = Math.max(g.bbox.x1, o.bbox.x1);
              g.bbox.y1 = Math.max(g.bbox.y1, o.bbox.y1);
              used.add(j);
            }
          }
        });

        if (g.words.length > 0) grps.push(g);
      });

      return grps;
    }

    function draw(ctx, bbox, txt) {
      const p = 10;
      const x = bbox.x0 - p;
      const y = bbox.y0 - p;
      const w = bbox.x1 - bbox.x0 + p * 2;
      const h = bbox.y1 - bbox.y0 + p * 2;

      ctx.fillStyle = 'rgba(255,255,255,0.98)';
      ctx.fillRect(x, y, w, h);

      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, w, h);

      ctx.fillStyle = '#000';
      const fs = Math.max(Math.min(h * 0.4, 18), 12);
      ctx.font = 'bold ' + fs + 'px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      const words = txt.split(' ');
      const lines = [];
      let line = '';
      
      words.forEach(word => {
        const test = line + (line ? ' ' : '') + word;
        if (ctx.measureText(test).width > w - 20 && line) {
          lines.push(line);
          line = word;
        } else {
          line = test;
        }
      });
      if (line) lines.push(line);

      const lh = fs * 1.2;
      const sy = y + h / 2 - (lines.length * lh) / 2 + fs / 2;

      lines.forEach((l, i) => ctx.fillText(l, x + w / 2, sy + i * lh));
    }

    async function translate(txt) {
      if (!txt || txt.trim().length === 0) return txt;
      const fromLang = getLang(from.value);
      const toLang = to.value;

      try {
        const url = 'https://api.mymemory.translated.net/get?q=' + encodeURIComponent(txt) + '&langpair=' + fromLang + '|' + toLang;
        const r = await fetch(url);
        const d = await r.json();
        if (d.responseStatus === 200 && d.responseData.translatedText) return d.responseData.translatedText;
      } catch (e) {}

      return txt;
    }

    function getLang(c) {
      const map = { 'eng': 'en', 'por': 'pt', 'spa': 'es' };
      return map[c] || c;
    }

    function upd(cur, tot, msg) {
      if (cur !== null && tot !== null) fill.style.width = (cur / tot) * 100 + '%';
      text.textContent = msg;
    }

    function showRes() {
      results.classList.remove('hidden');
      out.innerHTML = '';
      sb.textContent = tb;
      st.textContent = tt;
      si.textContent = imgs.length;
      imgs.forEach(src => {
        const img = document.createElement('img');
        img.src = src;
        img.className = 'result-img';
        out.appendChild(img);
      });
      prog.classList.add('hidden');
      prev.classList.add('hidden');
      go.disabled = false;
    }

    function showErr(m) {
      err.textContent = '❌ ' + m;
      err.classList.remove('hidden');
    }

    function hideErr() {
      err.classList.add('hidden');
    }

    dl.onclick = () => {
      imgs.forEach((src, i) => {
        const a = document.createElement('a');
        a.href = src;
        a.download = 'manga-' + (i + 1) + '.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      });
    };

    newBtn.onclick = () => location.reload();

    console.log('✅ V4.2 - Agrupamento balanceado com limite de tamanho!');
  </script>
</body>
</html>
