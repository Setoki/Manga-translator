<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tradutor de MangÃ¡ V5.0 - DETECÃ‡ÃƒO DE BALÃ•ES</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
    .container { max-width: 900px; margin: 0 auto; }
    .header { text-align: center; color: white; margin-bottom: 30px; }
    .header h1 { font-size: 36px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
    .version { background: rgba(255,255,255,0.3); padding: 10px 24px; border-radius: 20px; font-size: 15px; display: inline-block; font-weight: bold; margin-top: 12px; }
    .card { background: white; border-radius: 18px; padding: 30px; box-shadow: 0 10px 30px rgba(0,0,0,0.25); margin-bottom: 24px; }
    .settings { display: grid; grid-template-columns: 1fr 1fr; gap: 18px; margin-bottom: 24px; }
    .setting { padding: 18px; background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%); border-radius: 12px; border: 2px solid #e5e7eb; }
    .setting label { display: block; font-size: 14px; font-weight: bold; margin-bottom: 10px; color: #1f2937; }
    .setting select { width: 100%; padding: 12px; border: 2px solid #d1d5db; border-radius: 8px; font-size: 15px; background: white; cursor: pointer; }
    .upload-btn { width: 100%; padding: 60px 24px; background: linear-gradient(135deg, #667eea, #764ba2); border: none; border-radius: 16px; color: white; font-size: 20px; font-weight: bold; cursor: pointer; text-align: center; transition: all 0.3s; }
    .upload-btn:hover { transform: translateY(-4px); box-shadow: 0 12px 24px rgba(102, 126, 234, 0.4); }
    .icon { font-size: 56px; display: block; margin-bottom: 18px; }
    input[type="file"] { display: none; }
    .preview { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 18px; margin-top: 24px; }
    .preview-item { position: relative; border-radius: 12px; overflow: hidden; border: 3px solid #e5e7eb; transition: all 0.3s; }
    .preview-item:hover { border-color: #667eea; transform: scale(1.05); }
    .preview-item img { width: 100%; height: 160px; object-fit: cover; }
    .remove { position: absolute; top: 10px; right: 10px; background: #ef4444; color: white; border: none; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-size: 20px; font-weight: bold; }
    .btn { width: 100%; padding: 18px; border: none; border-radius: 10px; font-size: 17px; font-weight: bold; cursor: pointer; margin-top: 18px; transition: all 0.3s; }
    .btn-primary { background: linear-gradient(135deg, #667eea, #764ba2); color: white; }
    .btn-primary:hover:not(:disabled) { transform: translateY(-3px); box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4); }
    .btn-success { background: linear-gradient(135deg, #10b981, #059669); color: white; }
    .btn-secondary { background: linear-gradient(135deg, #6b7280, #4b5563); color: white; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    .progress { margin-top: 24px; }
    .progress-bar { width: 100%; height: 12px; background: #e5e7eb; border-radius: 6px; overflow: hidden; margin-bottom: 12px; }
    .progress-fill { height: 100%; background: linear-gradient(90deg, #667eea, #764ba2); width: 0%; transition: width 0.3s; }
    .progress-text { text-align: center; font-size: 15px; color: #4b5563; font-weight: 600; }
    .result-img { width: 100%; border-radius: 12px; margin-bottom: 18px; border: 3px solid #e5e7eb; }
    .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .alert { padding: 18px; border-radius: 12px; margin-top: 18px; font-size: 15px; line-height: 1.6; }
    .alert-error { background: linear-gradient(135deg, #fee2e2, #fecaca); color: #991b1b; border: 2px solid #fca5a5; }
    .alert-info { background: linear-gradient(135deg, #dbeafe, #bfdbfe); color: #1e40af; border: 2px solid #93c5fd; }
    .alert-success { background: linear-gradient(135deg, #d1fae5, #a7f3d0); color: #065f46; border: 2px solid #6ee7b7; }
    .hidden { display: none; }
    .stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 24px; }
    .stat { text-align: center; padding: 20px; background: linear-gradient(135deg, #f9fafb, #f3f4f6); border-radius: 12px; border: 2px solid #e5e7eb; }
    .stat-num { font-size: 32px; font-weight: bold; color: #667eea; }
    .stat-label { font-size: 13px; color: #6b7280; margin-top: 6px; font-weight: 600; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>ğŸŒ Tradutor de MangÃ¡ PRO</h1>
      <div class="version">ğŸš€ V5.0 - DETECÃ‡ÃƒO DE BALÃ•ES</div>
    </div>

    <div class="card">
      <div class="settings">
        <div class="setting">
          <label>ğŸ—£ï¸ Idioma de Origem</label>
          <select id="from">
            <option value="eng">ğŸ‡ºğŸ‡¸ InglÃªs</option>
            <option value="por">ğŸ‡§ğŸ‡· PortuguÃªs</option>
            <option value="spa">ğŸ‡ªğŸ‡¸ Espanhol</option>
          </select>
        </div>
        <div class="setting">
          <label>ğŸ¯ Traduzir Para</label>
          <select id="to">
            <option value="pt">ğŸ‡§ğŸ‡· PortuguÃªs BR</option>
            <option value="en">ğŸ‡ºğŸ‡¸ InglÃªs</option>
            <option value="es">ğŸ‡ªğŸ‡¸ Espanhol</option>
          </select>
        </div>
      </div>

      <button class="upload-btn" id="upload">
        <span class="icon">ğŸ“¤</span>
        <div>CLIQUE PARA ESCOLHER IMAGENS</div>
        <div style="font-size: 16px; margin-top: 12px; opacity: 0.9;">MÃ¡ximo 2 imagens por vez</div>
      </button>
      <input type="file" id="file" accept="image/*" multiple>
      
      <div id="prev" class="hidden">
        <h3 style="margin-top: 24px; font-size: 18px;">ğŸ“¸ Imagens Selecionadas:</h3>
        <div id="grid" class="preview"></div>
        <button class="btn btn-primary" id="go">ğŸš€ TRADUZIR COM DETECÃ‡ÃƒO DE BALÃ•ES</button>
      </div>

      <div id="prog" class="hidden progress">
        <div class="progress-bar"><div class="progress-fill" id="fill"></div></div>
        <div class="progress-text" id="text">Processando...</div>
      </div>
    </div>

    <div id="results" class="card hidden">
      <h3 style="text-align: center; color: #10b981; margin-bottom: 24px; font-size: 22px;">âœ… TraduÃ§Ã£o ConcluÃ­da!</h3>
      <div class="stats">
        <div class="stat"><div class="stat-num" id="sb">0</div><div class="stat-label">BalÃµes Detectados</div></div>
        <div class="stat"><div class="stat-num" id="st">0</div><div class="stat-label">Textos Traduzidos</div></div>
        <div class="stat"><div class="stat-num" id="si">0</div><div class="stat-label">Imagens</div></div>
      </div>
      <div id="out"></div>
      <div class="btn-group">
        <button class="btn btn-success" id="dl">ğŸ’¾ Baixar Todas</button>
        <button class="btn btn-secondary" id="new">ğŸ”„ Nova TraduÃ§Ã£o</button>
      </div>
    </div>

    <div class="alert alert-info">
      <strong>ğŸ’¡ NOVA ABORDAGEM V5.0:</strong><br>
      ğŸ¯ <strong>Detecta balÃµes completos</strong> primeiro (Ã¡reas brancas grandes)<br>
      ğŸ“ <strong>Extrai TODO o texto</strong> dentro de cada balÃ£o<br>
      ğŸŒ <strong>Traduz o texto completo</strong> de uma vez<br>
      ğŸ“¦ <strong>Desenha UMA caixa</strong> por balÃ£o com a traduÃ§Ã£o<br>
      <br>
      âš¡ Resultado: Textos contÃ­nuos, nÃ£o mais fragmentados!
    </div>
    <div id="err" class="alert alert-error hidden"></div>
  </div>

  <script>
    const upload = document.getElementById('upload');
    const file = document.getElementById('file');
    const prev = document.getElementById('prev');
    const grid = document.getElementById('grid');
    const go = document.getElementById('go');
    const prog = document.getElementById('prog');
    const fill = document.getElementById('fill');
    const text = document.getElementById('text');
    const results = document.getElementById('results');
    const out = document.getElementById('out');
    const sb = document.getElementById('sb');
    const st = document.getElementById('st');
    const si = document.getElementById('si');
    const dl = document.getElementById('dl');
    const newBtn = document.getElementById('new');
    const from = document.getElementById('from');
    const to = document.getElementById('to');
    const err = document.getElementById('err');

    let files = [];
    let imgs = [];
    let tb = 0;
    let tt = 0;

    upload.onclick = () => file.click();

    file.onchange = e => {
      const f = Array.from(e.target.files);
      if (f.length === 0) return showErr('Nenhum arquivo selecionado!');
      if (f.length > 2) return showErr('MÃ¡ximo 2 imagens por vez!');
      files = f;
      showPreview();
      hideErr();
    };

    function showPreview() {
      grid.innerHTML = '';
      prev.classList.remove('hidden');
      files.forEach((f, i) => {
        const r = new FileReader();
        r.onload = e => {
          const d = document.createElement('div');
          d.className = 'preview-item';
          d.innerHTML = '<img src="' + e.target.result + '"><button class="remove" onclick="removeImg(' + i + ')">Ã—</button>';
          grid.appendChild(d);
        };
        r.readAsDataURL(f);
      });
    }

    window.removeImg = i => {
      files.splice(i, 1);
      files.length === 0 ? (prev.classList.add('hidden'), file.value = '') : showPreview();
    };

    go.onclick = async () => {
      go.disabled = true;
      prog.classList.remove('hidden');
      results.classList.add('hidden');
      imgs = [];
      tb = 0;
      tt = 0;

      try {
        for (let i = 0; i < files.length; i++) {
          upd(i, files.length, 'ğŸ” Processando imagem ' + (i + 1) + '/' + files.length + '...');
          const r = await procBalloon(files[i], i + 1);
          imgs.push(r);
        }
        upd(files.length, files.length, 'âœ… ConcluÃ­do!');
        showRes();
      } catch (error) {
        console.error('Erro:', error);
        showErr('Erro: ' + error.message);
        go.disabled = false;
        prog.classList.add('hidden');
      }
    };

    async function procBalloon(f, n) {
      return new Promise((res, rej) => {
        const r = new FileReader();
        r.onload = async e => {
          const img = new Image();
          img.onload = async () => {
            const c = document.createElement('canvas');
            const ctx = c.getContext('2d');
            c.width = img.width;
            c.height = img.height;
            ctx.drawImage(img, 0, 0);

            upd(null, null, 'ğŸ¯ Detectando balÃµes na imagem ' + n + '...');

            // ETAPA 1: Detectar regiÃµes de balÃµes (Ã¡reas brancas)
            const balloons = detectBalloons(ctx, c.width, c.height);
            console.log('BalÃµes detectados:', balloons.length);
            tb += balloons.length;

            upd(null, null, 'ğŸ“ Extraindo texto com OCR...');

            try {
              // ETAPA 2: OCR na imagem completa
              const ocr = await Tesseract.recognize(c, from.value, {
                logger: m => m.status === 'recognizing text' && upd(null, null, 'OCR: ' + Math.round(m.progress * 100) + '%')
              });

              const words = ocr.data.words.filter(w => w.confidence > 45 && w.text.trim().length >= 3);

              // ETAPA 3: Para cada balÃ£o, pegar palavras dentro dele
              for (let i = 0; i < balloons.length; i++) {
                const balloon = balloons[i];
                upd(null, null, 'ğŸŒ Traduzindo balÃ£o ' + (i + 1) + '/' + balloons.length + '...');

                // Palavras dentro deste balÃ£o
                const wordsInBalloon = words.filter(w => isInside(w.bbox, balloon));
                
                if (wordsInBalloon.length > 0) {
                  // Ordenar palavras por posiÃ§Ã£o
                  wordsInBalloon.sort((a, b) => {
                    if (Math.abs(a.bbox.y0 - b.bbox.y0) > 20) return a.bbox.y0 - b.bbox.y0;
                    return a.bbox.x0 - b.bbox.x0;
                  });

                  const fullText = wordsInBalloon.map(w => w.text).join(' ');
                  console.log('Texto do balÃ£o:', fullText);

                  const translation = await translate(fullText);
                  tt++;

                  // Desenhar UMA caixa para TODO o balÃ£o
                  drawBalloonText(ctx, balloon, translation);
                }
              }

              res(c.toDataURL('image/png', 0.95));
            } catch (e) {
              console.error('Erro OCR:', e);
              rej(new Error('Falha no OCR'));
            }
          };
          img.onerror = () => rej(new Error('Erro ao carregar imagem'));
          img.src = e.target.result;
        };
        r.onerror = () => rej(new Error('Erro ao ler arquivo'));
        r.readAsDataURL(f);
      });
    }

    function detectBalloons(ctx, w, h) {
      const imgData = ctx.getImageData(0, 0, w, h);
      const data = imgData.data;
      const balloons = [];
      const threshold = 200;
      const minSize = 2000; // Ãrea mÃ­nima
      const maxSize = w * h * 0.3; // NOVO: MÃ¡ximo 30% da imagem (evita pÃ¡gina inteira)

      // Criar mapa binÃ¡rio
      const binary = new Uint8Array(w * h);
      for (let i = 0; i < data.length; i += 4) {
        const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
        binary[i / 4] = brightness > threshold ? 1 : 0;
      }

      // Detectar regiÃµes retangulares brancas
      const step = 35;
      const minW = 100;
      const minH = 80;
      const maxW = w * 0.6; // NOVO: Largura mÃ¡xima 60% da imagem
      const maxH = h * 0.4; // NOVO: Altura mÃ¡xima 40% da imagem

      for (let y = 0; y < h - minH; y += step) {
        for (let x = 0; x < w - minW; x += step) {
          // Verificar se regiÃ£o inicial Ã© branca
          let whites = 0;
          let total = 0;

          for (let dy = 0; dy < 80; dy += 4) {
            for (let dx = 0; dx < 80; dx += 4) {
              if (y + dy < h && x + dx < w) {
                if (binary[(y + dy) * w + (x + dx)] === 1) whites++;
                total++;
              }
            }
          }

          if (whites / total > 0.75) {
            // Expandir regiÃ£o
            let width = 80;
            let height = 80;

            // Expandir horizontalmente (com limite)
            while (x + width < w - 10 && width < maxW) {
              let edge = 0;
              let edgeTotal = 0;
              for (let dy = 0; dy < height; dy += 4) {
                if (y + dy < h) {
                  if (binary[(y + dy) * w + (x + width)] === 1) edge++;
                  edgeTotal++;
                }
              }
              if (edge / edgeTotal < 0.65) break;
              width += 8;
            }

            // Expandir verticalmente (com limite)
            while (y + height < h - 10 && height < maxH) {
              let edge = 0;
              let edgeTotal = 0;
              for (let dx = 0; dx < width; dx += 4) {
                if (x + dx < w) {
                  if (binary[(y + height) * w + (x + dx)] === 1) edge++;
                  edgeTotal++;
                }
              }
              if (edge / edgeTotal < 0.65) break;
              height += 8;
            }

            const area = width * height;
            
            // NOVO: Verificar se nÃ£o Ã© muito grande nem muito pequeno
            if (area > minSize && area < maxSize && width < maxW && height < maxH) {
              // Verificar sobreposiÃ§Ã£o
              const overlap = balloons.some(b => {
                const overlapX = Math.max(0, Math.min(x + width, b.x + b.w) - Math.max(x, b.x));
                const overlapY = Math.max(0, Math.min(y + height, b.y + b.h) - Math.max(y, b.y));
                const overlapArea = overlapX * overlapY;
                return overlapArea > area * 0.3; // Mais de 30% de sobreposiÃ§Ã£o
              });
              
              if (!overlap) {
                balloons.push({ x, y, w: width, h: height });
              }
            }
          }
        }
      }

      // NOVO: Filtrar balÃµes que estÃ£o nas bordas da imagem (provavelmente nÃ£o sÃ£o balÃµes)
      return balloons.filter(b => {
        const notOnEdge = b.x > 20 && b.y > 20 && 
                         b.x + b.w < w - 20 && b.y + b.h < h - 20;
        const reasonableSize = b.w < w * 0.5 && b.h < h * 0.4;
        return notOnEdge && reasonableSize;
      });
    }

    function isInside(bbox, balloon) {
      const cx = (bbox.x0 + bbox.x1) / 2;
      const cy = (bbox.y0 + bbox.y1) / 2;
      return cx >= balloon.x && cx <= balloon.x + balloon.w &&
             cy >= balloon.y && cy <= balloon.y + balloon.h;
    }

    function drawBalloonText(ctx, balloon, txt) {
      const pad = 12;
      const x = balloon.x + pad;
      const y = balloon.y + pad;
      const w = balloon.w - pad * 2;
      const h = balloon.h - pad * 2;

      // Fundo branco opaco
      ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
      ctx.fillRect(balloon.x, balloon.y, balloon.w, balloon.h);

      // Borda
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2.5;
      ctx.strokeRect(balloon.x, balloon.y, balloon.w, balloon.h);

      // Texto
      ctx.fillStyle = '#000';
      const fs = Math.max(Math.min(h * 0.25, 20), 13);
      ctx.font = 'bold ' + fs + 'px Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Quebrar em linhas
      const words = txt.split(' ');
      const lines = [];
      let line = '';

      words.forEach(word => {
        const test = line + (line ? ' ' : '') + word;
        if (ctx.measureText(test).width > w - 24 && line) {
          lines.push(line);
          line = word;
        } else {
          line = test;
        }
      });
      if (line) lines.push(line);

      const lh = fs * 1.3;
      const sy = balloon.y + balloon.h / 2 - (lines.length * lh) / 2 + fs / 2;

      lines.forEach((l, i) => {
        ctx.fillText(l, balloon.x + balloon.w / 2, sy + i * lh);
      });
    }

    async function translate(txt) {
      if (!txt || txt.trim().length === 0) return txt;
      const fromLang = getLang(from.value);
      const toLang = to.value;

      try {
        const url = 'https://api.mymemory.translated.net/get?q=' + encodeURIComponent(txt) + '&langpair=' + fromLang + '|' + toLang;
        const response = await fetch(url);
        const data = await response.json();
        if (data.responseStatus === 200 && data.responseData.translatedText) {
          return data.responseData.translatedText;
        }
      } catch (e) {
        console.warn('TraduÃ§Ã£o falhou:', e);
      }

      return txt;
    }

    function getLang(code) {
      const map = { 'eng': 'en', 'por': 'pt', 'spa': 'es' };
      return map[code] || code;
    }

    function upd(cur, tot, msg) {
      if (cur !== null && tot !== null) fill.style.width = (cur / tot) * 100 + '%';
      text.textContent = msg;
    }

    function showRes() {
      results.classList.remove('hidden');
      out.innerHTML = '';
      sb.textContent = tb;
      st.textContent = tt;
      si.textContent = imgs.length;
      imgs.forEach(src => {
        const img = document.createElement('img');
        img.src = src;
        img.className = 'result-img';
        out.appendChild(img);
      });
      prog.classList.add('hidden');
      prev.classList.add('hidden');
      go.disabled = false;
    }

    function showErr(m) {
      err.textContent = 'âŒ ' + m;
      err.classList.remove('hidden');
    }

    function hideErr() {
      err.classList.add('hidden');
    }

    dl.onclick = () => {
      imgs.forEach((src, i) => {
        const a = document.createElement('a');
        a.href = src;
        a.download = 'manga-traduzido-' + (i + 1) + '.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      });
    };

    newBtn.onclick = () => location.reload();

    console.log('ğŸš€ V5.0 - Sistema de DetecÃ§Ã£o de BalÃµes ativado!');
    console.log('ğŸ“‹ Fluxo: Detecta BalÃµes â†’ OCR â†’ Agrupa Texto por BalÃ£o â†’ Traduz â†’ Desenha');
  </script>
</body>
</html>
