<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tradutor de Mangá V5.0 - DETECÇÃO DE BALÕES</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
    .container { max-width: 900px; margin: 0 auto; }
    .header { text-align: center; color: white; margin-bottom: 30px; }
    .header h1 { font-size: 36px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
    .version { background: rgba(255,255,255,0.3); padding: 10px 24px; border-radius: 20px; font-size: 15px; display: inline-block; font-weight: bold; margin-top: 12px; }
    .card { background: white; border-radius: 18px; padding: 30px; box-shadow: 0 10px 30px rgba(0,0,0,0.25); margin-bottom: 24px; }
    .settings { display: grid; grid-template-columns: 1fr 1fr; gap: 18px; margin-bottom: 24px; }
    .setting { padding: 18px; background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%); border-radius: 12px; border: 2px solid #e5e7eb; }
    .setting label { display: block; font-size: 14px; font-weight: bold; margin-bottom: 10px; color: #1f2937; }
    .setting select { width: 100%; padding: 12px; border: 2px solid #d1d5db; border-radius: 8px; font-size: 15px; background: white; cursor: pointer; }
    .upload-btn { width: 100%; padding: 60px 24px; background: linear-gradient(135deg, #667eea, #764ba2); border: none; border-radius: 16px; color: white; font-size: 20px; font-weight: bold; cursor: pointer; text-align: center; transition: all 0.3s; }
    .upload-btn:hover { transform: translateY(-4px); box-shadow: 0 12px 24px rgba(102, 126, 234, 0.4); }
    .icon { font-size: 56px; display: block; margin-bottom: 18px; }
    input[type="file"] { display: none; }
    .preview { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 18px; margin-top: 24px; }
    .preview-item { position: relative; border-radius: 12px; overflow: hidden; border: 3px solid #e5e7eb; transition: all 0.3s; }
    .preview-item:hover { border-color: #667eea; transform: scale(1.05); }
    .preview-item img { width: 100%; height: 160px; object-fit: cover; }
    .remove { position: absolute; top: 10px; right: 10px; background: #ef4444; color: white; border: none; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-size: 20px; font-weight: bold; }
    .btn { width: 100%; padding: 18px; border: none; border-radius: 10px; font-size: 17px; font-weight: bold; cursor: pointer; margin-top: 18px; transition: all 0.3s; }
    .btn-primary { background: linear-gradient(135deg, #667eea, #764ba2); color: white; }
    .btn-primary:hover:not(:disabled) { transform: translateY(-3px); box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4); }
    .btn-success { background: linear-gradient(135deg, #10b981, #059669); color: white; }
    .btn-secondary { background: linear-gradient(135deg, #6b7280, #4b5563); color: white; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    .progress { margin-top: 24px; }
    .progress-bar { width: 100%; height: 12px; background: #e5e7eb; border-radius: 6px; overflow: hidden; margin-bottom: 12px; }
    .progress-fill { height: 100%; background: linear-gradient(90deg, #667eea, #764ba2); width: 0%; transition: width 0.3s; }
    .progress-text { text-align: center; font-size: 15px; color: #4b5563; font-weight: 600; }
    .result-img { width: 100%; border-radius: 12px; margin-bottom: 18px; border: 3px solid #e5e7eb; }
    .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .alert { padding: 18px; border-radius: 12px; margin-top: 18px; font-size: 15px; line-height: 1.6; }
    .alert-error { background: linear-gradient(135deg, #fee2e2, #fecaca); color: #991b1b; border: 2px solid #fca5a5; }
    .alert-info { background: linear-gradient(135deg, #dbeafe, #bfdbfe); color: #1e40af; border: 2px solid #93c5fd; }
    .alert-success { background: linear-gradient(135deg, #d1fae5, #a7f3d0); color: #065f46; border: 2px solid #6ee7b7; }
    .hidden { display: none; }
    .stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 24px; }
    .stat { text-align: center; padding: 20px; background: linear-gradient(135deg, #f9fafb, #f3f4f6); border-radius: 12px; border: 2px solid #e5e7eb; }
    .stat-num { font-size: 32px; font-weight: bold; color: #667eea; }
    .stat-label { font-size: 13px; color: #6b7280; margin-top: 6px; font-weight: 600; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>🌐 Tradutor de Mangá PRO</h1>
      <div class="version">🚀 V5.0 - DETECÇÃO DE BALÕES</div>
    </div>

    <div class="card">
      <div class="settings">
        <div class="setting">
          <label>🗣️ Idioma de Origem</label>
          <select id="from">
            <option value="eng">🇺🇸 Inglês</option>
            <option value="por">🇧🇷 Português</option>
            <option value="spa">🇪🇸 Espanhol</option>
          </select>
        </div>
        <div class="setting">
          <label>🎯 Traduzir Para</label>
          <select id="to">
            <option value="pt">🇧🇷 Português BR</option>
            <option value="en">🇺🇸 Inglês</option>
            <option value="es">🇪🇸 Espanhol</option>
          </select>
        </div>
      </div>

      <button class="upload-btn" id="upload">
        <span class="icon">📤</span>
        <div>CLIQUE PARA ESCOLHER IMAGENS</div>
        <div style="font-size: 16px; margin-top: 12px; opacity: 0.9;">Máximo 2 imagens por vez</div>
      </button>
      <input type="file" id="file" accept="image/*" multiple>
      
      <div id="prev" class="hidden">
        <h3 style="margin-top: 24px; font-size: 18px;">📸 Imagens Selecionadas:</h3>
        <div id="grid" class="preview"></div>
        <button class="btn btn-primary" id="go">🚀 TRADUZIR COM DETECÇÃO DE BALÕES</button>
      </div>

      <div id="prog" class="hidden progress">
        <div class="progress-bar"><div class="progress-fill" id="fill"></div></div>
        <div class="progress-text" id="text">Processando...</div>
      </div>
    </div>

    <div id="results" class="card hidden">
      <h3 style="text-align: center; color: #10b981; margin-bottom: 24px; font-size: 22px;">✅ Tradução Concluída!</h3>
      <div class="stats">
        <div class="stat"><div class="stat-num" id="sb">0</div><div class="stat-label">Balões Detectados</div></div>
        <div class="stat"><div class="stat-num" id="st">0</div><div class="stat-label">Textos Traduzidos</div></div>
        <div class="stat"><div class="stat-num" id="si">0</div><div class="stat-label">Imagens</div></div>
      </div>
      <div id="out"></div>
      <div class="btn-group">
        <button class="btn btn-success" id="dl">💾 Baixar Todas</button>
        <button class="btn btn-secondary" id="new">🔄 Nova Tradução</button>
      </div>
    </div>

    <div class="alert alert-info">
      <strong>💡 NOVA ABORDAGEM V5.0:</strong><br>
      🎯 <strong>Detecta balões completos</strong> primeiro (áreas brancas grandes)<br>
      📝 <strong>Extrai TODO o texto</strong> dentro de cada balão<br>
      🌐 <strong>Traduz o texto completo</strong> de uma vez<br>
      📦 <strong>Desenha UMA caixa</strong> por balão com a tradução<br>
      <br>
      ⚡ Resultado: Textos contínuos, não mais fragmentados!
    </div>
    <div id="err" class="alert alert-error hidden"></div>
  </div>

  <script>
    const upload = document.getElementById('upload');
    const file = document.getElementById('file');
    const prev = document.getElementById('prev');
    const grid = document.getElementById('grid');
    const go = document.getElementById('go');
    const prog = document.getElementById('prog');
    const fill = document.getElementById('fill');
    const text = document.getElementById('text');
    const results = document.getElementById('results');
    const out = document.getElementById('out');
    const sb = document.getElementById('sb');
    const st = document.getElementById('st');
    const si = document.getElementById('si');
    const dl = document.getElementById('dl');
    const newBtn = document.getElementById('new');
    const from = document.getElementById('from');
    const to = document.getElementById('to');
    const err = document.getElementById('err');

    let files = [];
    let imgs = [];
    let tb = 0;
    let tt = 0;

    upload.onclick = () => file.click();

    file.onchange = e => {
      const f = Array.from(e.target.files);
      if (f.length === 0) return showErr('Nenhum arquivo selecionado!');
      if (f.length > 2) return showErr('Máximo 2 imagens por vez!');
      files = f;
      showPreview();
      hideErr();
    };

    function showPreview() {
      grid.innerHTML = '';
      prev.classList.remove('hidden');
      files.forEach((f, i) => {
        const r = new FileReader();
        r.onload = e => {
          const d = document.createElement('div');
          d.className = 'preview-item';
          d.innerHTML = '<img src="' + e.target.result + '"><button class="remove" onclick="removeImg(' + i + ')">×</button>';
          grid.appendChild(d);
        };
        r.readAsDataURL(f);
      });
    }

    window.removeImg = i => {
      files.splice(i, 1);
      files.length === 0 ? (prev.classList.add('hidden'), file.value = '') : showPreview();
    };

    go.onclick = async () => {
      go.disabled = true;
      prog.classList.remove('hidden');
      results.classList.add('hidden');
      imgs = [];
      tb = 0;
      tt = 0;

      try {
        for (let i = 0; i < files.length; i++) {
          upd(i, files.length, '🔍 Processando imagem ' + (i + 1) + '/' + files.length + '...');
          const r = await procBalloon(files[i], i + 1);
          imgs.push(r);
        }
        upd(files.length, files.length, '✅ Concluído!');
        showRes();
      } catch (error) {
        console.error('Erro:', error);
        showErr('Erro: ' + error.message);
        go.disabled = false;
        prog.classList.add('hidden');
      }
    };

    async function procBalloon(f, n) {
      return new Promise((res, rej) => {
        const r = new FileReader();
        r.onload = async e => {
          const img = new Image();
          img.onload = async () => {
            const c = document.createElement('canvas');
            const ctx = c.getContext('2d');
            c.width = img.width;
            c.height = img.height;
            ctx.drawImage(img, 0, 0);

            upd(null, null, '🎯 Detectando balões na imagem ' + n + '...');

            // ETAPA 1: Detectar regiões de balões (áreas brancas)
            const balloons = detectBalloons(ctx, c.width, c.height);
            console.log('Balões detectados:', balloons.length);
            tb += balloons.length;

            upd(null, null, '📝 Extraindo texto com OCR...');

            try {
              // ETAPA 2: OCR na imagem completa
              const ocr = await Tesseract.recognize(c, from.value, {
                logger: m => m.status === 'recognizing text' && upd(null, null, 'OCR: ' + Math.round(m.progress * 100) + '%')
              });

              const words = ocr.data.words.filter(w => w.confidence > 45 && w.text.trim().length >= 3);

              // ETAPA 3: Para cada balão, pegar palavras dentro dele
              for (let i = 0; i < balloons.length; i++) {
                const balloon = balloons[i];
                upd(null, null, '🌐 Traduzindo balão ' + (i + 1) + '/' + balloons.length + '...');

                // Palavras dentro deste balão
                const wordsInBalloon = words.filter(w => isInside(w.bbox, balloon));
                
                if (wordsInBalloon.length > 0) {
                  // Ordenar palavras por posição
                  wordsInBalloon.sort((a, b) => {
                    if (Math.abs(a.bbox.y0 - b.bbox.y0) > 20) return a.bbox.y0 - b.bbox.y0;
                    return a.bbox.x0 - b.bbox.x0;
                  });

                  const fullText = wordsInBalloon.map(w => w.text).join(' ');
                  console.log('Texto do balão:', fullText);

                  const translation = await translate(fullText);
                  tt++;

                  // Desenhar UMA caixa para TODO o balão
                  drawBalloonText(ctx, balloon, translation);
                }
              }

              res(c.toDataURL('image/png', 0.95));
            } catch (e) {
              console.error('Erro OCR:', e);
              rej(new Error('Falha no OCR'));
            }
          };
          img.onerror = () => rej(new Error('Erro ao carregar imagem'));
          img.src = e.target.result;
        };
        r.onerror = () => rej(new Error('Erro ao ler arquivo'));
        r.readAsDataURL(f);
      });
    }

    function detectBalloons(ctx, w, h) {
      const imgData = ctx.getImageData(0, 0, w, h);
      const data = imgData.data;
      const balloons = [];
      const threshold = 200;
      const minSize = 2000; // Área mínima do balão

      // Criar mapa binário (branco/preto)
      const binary = new Uint8Array(w * h);
      for (let i = 0; i < data.length; i += 4) {
        const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
        binary[i / 4] = brightness > threshold ? 1 : 0;
      }

      // Detectar regiões retangulares brancas
      const step = 40;
      const minW = 80;
      const minH = 60;

      for (let y = 0; y < h - minH; y += step) {
        for (let x = 0; x < w - minW; x += step) {
          // Verificar se região é majoritariamente branca
          let whites = 0;
          let total = 0;

          for (let dy = 0; dy < 100; dy += 5) {
            for (let dx = 0; dx < 100; dx += 5) {
              if (y + dy < h && x + dx < w) {
                if (binary[(y + dy) * w + (x + dx)] === 1) whites++;
                total++;
              }
            }
          }

          if (whites / total > 0.7) {
            // Expandir região
            let width = 100;
            let height = 100;

            // Expandir horizontalmente
            while (x + width < w - 10) {
              let edge = 0;
              let edgeTotal = 0;
              for (let dy = 0; dy < height; dy += 5) {
                if (y + dy < h) {
                  if (binary[(y + dy) * w + (x + width)] === 1) edge++;
                  edgeTotal++;
                }
              }
              if (edge / edgeTotal < 0.6) break;
              width += 10;
            }

            // Expandir verticalmente
            while (y + height < h - 10) {
              let edge = 0;
              let edgeTotal = 0;
              for (let dx = 0; dx < width; dx += 5) {
                if (x + dx < w) {
                  if (binary[(y + height) * w + (x + dx)] === 1) edge++;
                  edgeTotal++;
                }
              }
              if (edge / edgeTotal < 0.6) break;
              height += 10;
            }

            const area = width * height;
            if (area > minSize) {
              // Verificar se não sobrepõe muito com balões existentes
              const overlap = balloons.some(b => 
                !(x > b.x + b.w || x + width < b.x || y > b.y + b.h || y + height < b.y)
              );
              
              if (!overlap) {
                balloons.push({ x, y, w: width, h: height });
              }
            }
          }
        }
      }

      return balloons;
    }

    function isInside(bbox, balloon) {
      const cx = (bbox.x0 + bbox.x1) / 2;
      const cy = (bbox.y0 + bbox.y1) / 2;
      return cx >= balloon.x && cx <= balloon.x + balloon.w &&
             cy >= balloon.y && cy <= balloon.y + balloon.h;
    }

    function drawBalloonText(ctx, balloon, txt) {
      const pad = 12;
      const x = balloon.x + pad;
      const y = balloon.y + pad;
      const w = balloon.w - pad * 2;
      const h = balloon.h - pad * 2;

      // Fundo branco opaco
      ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
      ctx.fillRect(balloon.x, balloon.y, balloon.w, balloon.h);

      // Borda
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2.5;
      ctx.strokeRect(balloon.x, balloon.y, balloon.w, balloon.h);

      // Texto
      ctx.fillStyle = '#000';
      const fs = Math.max(Math.min(h * 0.25, 20), 13);
      ctx.font = 'bold ' + fs + 'px Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      // Quebrar em linhas
      const words = txt.split(' ');
      const lines = [];
      let line = '';

      words.forEach(word => {
        const test = line + (line ? ' ' : '') + word;
        if (ctx.measureText(test).width > w - 24 && line) {
          lines.push(line);
          line = word;
        } else {
          line = test;
        }
      });
      if (line) lines.push(line);

      const lh = fs * 1.3;
      const sy = balloon.y + balloon.h / 2 - (lines.length * lh) / 2 + fs / 2;

      lines.forEach((l, i) => {
        ctx.fillText(l, balloon.x + balloon.w / 2, sy + i * lh);
      });
    }

    async function translate(txt) {
      if (!txt || txt.trim().length === 0) return txt;
      const fromLang = getLang(from.value);
      const toLang = to.value;

      try {
        const url = 'https://api.mymemory.translated.net/get?q=' + encodeURIComponent(txt) + '&langpair=' + fromLang + '|' + toLang;
        const response = await fetch(url);
        const data = await response.json();
        if (data.responseStatus === 200 && data.responseData.translatedText) {
          return data.responseData.translatedText;
        }
      } catch (e) {
        console.warn('Tradução falhou:', e);
      }

      return txt;
    }

    function getLang(code) {
      const map = { 'eng': 'en', 'por': 'pt', 'spa': 'es' };
      return map[code] || code;
    }

    function upd(cur, tot, msg) {
      if (cur !== null && tot !== null) fill.style.width = (cur / tot) * 100 + '%';
      text.textContent = msg;
    }

    function showRes() {
      results.classList.remove('hidden');
      out.innerHTML = '';
      sb.textContent = tb;
      st.textContent = tt;
      si.textContent = imgs.length;
      imgs.forEach(src => {
        const img = document.createElement('img');
        img.src = src;
        img.className = 'result-img';
        out.appendChild(img);
      });
      prog.classList.add('hidden');
      prev.classList.add('hidden');
      go.disabled = false;
    }

    function showErr(m) {
      err.textContent = '❌ ' + m;
      err.classList.remove('hidden');
    }

    function hideErr() {
      err.classList.add('hidden');
    }

    dl.onclick = () => {
      imgs.forEach((src, i) => {
        const a = document.createElement('a');
        a.href = src;
        a.download = 'manga-traduzido-' + (i + 1) + '.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      });
    };

    newBtn.onclick = () => location.reload();

    console.log('🚀 V5.0 - Sistema de Detecção de Balões ativado!');
    console.log('📋 Fluxo: Detecta Balões → OCR → Agrupa Texto por Balão → Traduz → Desenha');
  </script>
</body>
</html>
