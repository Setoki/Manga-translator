<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tradutor de Mangá V5.1 - CLUSTERING INTELIGENTE</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
    .container { max-width: 900px; margin: 0 auto; }
    .header { text-align: center; color: white; margin-bottom: 30px; }
    .header h1 { font-size: 36px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
    .version { background: rgba(255,255,255,0.35); padding: 10px 24px; border-radius: 20px; font-size: 15px; display: inline-block; font-weight: bold; margin-top: 12px; }
    .card { background: white; border-radius: 18px; padding: 30px; box-shadow: 0 10px 30px rgba(0,0,0,0.25); margin-bottom: 24px; }
    .settings { display: grid; grid-template-columns: 1fr 1fr; gap: 18px; margin-bottom: 24px; }
    .setting { padding: 18px; background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%); border-radius: 12px; border: 2px solid #e5e7eb; }
    .setting label { display: block; font-size: 14px; font-weight: bold; margin-bottom: 10px; color: #1f2937; }
    .setting select { width: 100%; padding: 12px; border: 2px solid #d1d5db; border-radius: 8px; font-size: 15px; background: white; cursor: pointer; }
    .upload-btn { width: 100%; padding: 60px 24px; background: linear-gradient(135deg, #667eea, #764ba2); border: none; border-radius: 16px; color: white; font-size: 20px; font-weight: bold; cursor: pointer; text-align: center; transition: all 0.3s; }
    .upload-btn:hover { transform: translateY(-4px); box-shadow: 0 12px 24px rgba(102, 126, 234, 0.4); }
    .icon { font-size: 56px; display: block; margin-bottom: 18px; }
    input[type="file"] { display: none; }
    .preview { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 18px; margin-top: 24px; }
    .preview-item { position: relative; border-radius: 12px; overflow: hidden; border: 3px solid #e5e7eb; transition: all 0.3s; }
    .preview-item:hover { border-color: #667eea; transform: scale(1.05); }
    .preview-item img { width: 100%; height: 160px; object-fit: cover; }
    .remove { position: absolute; top: 10px; right: 10px; background: #ef4444; color: white; border: none; width: 32px; height: 32px; border-radius: 50%; cursor: pointer; font-size: 20px; font-weight: bold; }
    .btn { width: 100%; padding: 18px; border: none; border-radius: 10px; font-size: 17px; font-weight: bold; cursor: pointer; margin-top: 18px; transition: all 0.3s; }
    .btn-primary { background: linear-gradient(135deg, #667eea, #764ba2); color: white; }
    .btn-primary:hover:not(:disabled) { transform: translateY(-3px); box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4); }
    .btn-success { background: linear-gradient(135deg, #10b981, #059669); color: white; }
    .btn-secondary { background: linear-gradient(135deg, #6b7280, #4b5563); color: white; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    .progress { margin-top: 24px; }
    .progress-bar { width: 100%; height: 12px; background: #e5e7eb; border-radius: 6px; overflow: hidden; margin-bottom: 12px; }
    .progress-fill { height: 100%; background: linear-gradient(90deg, #667eea, #764ba2); width: 0%; transition: width 0.3s; }
    .progress-text { text-align: center; font-size: 15px; color: #4b5563; font-weight: 600; }
    .result-img { width: 100%; border-radius: 12px; margin-bottom: 18px; border: 3px solid #e5e7eb; }
    .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .alert { padding: 18px; border-radius: 12px; margin-top: 18px; font-size: 15px; line-height: 1.6; }
    .alert-error { background: linear-gradient(135deg, #fee2e2, #fecaca); color: #991b1b; border: 2px solid #fca5a5; }
    .alert-info { background: linear-gradient(135deg, #dbeafe, #bfdbfe); color: #1e40af; border: 2px solid #93c5fd; }
    .hidden { display: none; }
    .stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 24px; }
    .stat { text-align: center; padding: 20px; background: linear-gradient(135deg, #f9fafb, #f3f4f6); border-radius: 12px; border: 2px solid #e5e7eb; }
    .stat-num { font-size: 32px; font-weight: bold; color: #667eea; }
    .stat-label { font-size: 13px; color: #6b7280; margin-top: 6px; font-weight: 600; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>🌐 Tradutor de Mangá PRO</h1>
      <div class="version">🧠 V5.1 - CLUSTERING INTELIGENTE</div>
    </div>

    <div class="card">
      <div class="settings">
        <div class="setting">
          <label>🗣️ Idioma de Origem</label>
          <select id="from">
            <option value="eng">🇺🇸 Inglês</option>
            <option value="por">🇧🇷 Português</option>
            <option value="spa">🇪🇸 Espanhol</option>
          </select>
        </div>
        <div class="setting">
          <label>🎯 Traduzir Para</label>
          <select id="to">
            <option value="pt">🇧🇷 Português BR</option>
            <option value="en">🇺🇸 Inglês</option>
            <option value="es">🇪🇸 Espanhol</option>
          </select>
        </div>
      </div>

      <button class="upload-btn" id="upload">
        <span class="icon">📤</span>
        <div>CLIQUE PARA ESCOLHER IMAGENS</div>
        <div style="font-size: 16px; margin-top: 12px; opacity: 0.9;">Máximo 2 imagens</div>
      </button>
      <input type="file" id="file" accept="image/*" multiple>
      
      <div id="prev" class="hidden">
        <h3 style="margin-top: 24px; font-size: 18px;">📸 Imagens:</h3>
        <div id="grid" class="preview"></div>
        <button class="btn btn-primary" id="go">🚀 TRADUZIR (Agrupamento Agressivo)</button>
      </div>

      <div id="prog" class="hidden progress">
        <div class="progress-bar"><div class="progress-fill" id="fill"></div></div>
        <div class="progress-text" id="text">Processando...</div>
      </div>
    </div>

    <div id="results" class="card hidden">
      <h3 style="text-align: center; color: #10b981; margin-bottom: 24px; font-size: 22px;">✅ Tradução Concluída!</h3>
      <div class="stats">
        <div class="stat"><div class="stat-num" id="sb">0</div><div class="stat-label">Balões</div></div>
        <div class="stat"><div class="stat-num" id="st">0</div><div class="stat-label">Traduções</div></div>
        <div class="stat"><div class="stat-num" id="si">0</div><div class="stat-label">Imagens</div></div>
      </div>
      <div id="out"></div>
      <div class="btn-group">
        <button class="btn btn-success" id="dl">💾 Baixar</button>
        <button class="btn btn-secondary" id="new">🔄 Nova</button>
      </div>
    </div>

    <div class="alert alert-info">
      <strong>💡 V5.1 - Clustering Hierárquico:</strong><br>
      🧠 <strong>Algoritmo inteligente</strong> agrupa palavras por proximidade<br>
      📊 <strong>Múltiplas passadas</strong> para garantir agrupamento completo<br>
      🎯 <strong>Limite de grupos</strong>: máximo 5 balões por imagem<br>
      📦 <strong>Caixas grandes</strong> com texto completo
    </div>
    <div id="err" class="alert alert-error hidden"></div>
  </div>

  <script>
    const upload = document.getElementById('upload');
    const file = document.getElementById('file');
    const prev = document.getElementById('prev');
    const grid = document.getElementById('grid');
    const go = document.getElementById('go');
    const prog = document.getElementById('prog');
    const fill = document.getElementById('fill');
    const text = document.getElementById('text');
    const results = document.getElementById('results');
    const out = document.getElementById('out');
    const sb = document.getElementById('sb');
    const st = document.getElementById('st');
    const si = document.getElementById('si');
    const dl = document.getElementById('dl');
    const newBtn = document.getElementById('new');
    const from = document.getElementById('from');
    const to = document.getElementById('to');
    const err = document.getElementById('err');

    let files = [];
    let imgs = [];
    let tb = 0;
    let tt = 0;

    upload.onclick = () => file.click();

    file.onchange = e => {
      const f = Array.from(e.target.files);
      if (f.length === 0) return showErr('Nenhum arquivo!');
      if (f.length > 2) return showErr('Máximo 2 imagens!');
      files = f;
      showPreview();
      hideErr();
    };

    function showPreview() {
      grid.innerHTML = '';
      prev.classList.remove('hidden');
      files.forEach((f, i) => {
        const r = new FileReader();
        r.onload = e => {
          const d = document.createElement('div');
          d.className = 'preview-item';
          d.innerHTML = '<img src="' + e.target.result + '"><button class="remove" onclick="removeImg(' + i + ')">×</button>';
          grid.appendChild(d);
        };
        r.readAsDataURL(f);
      });
    }

    window.removeImg = i => {
      files.splice(i, 1);
      files.length === 0 ? (prev.classList.add('hidden'), file.value = '') : showPreview();
    };

    go.onclick = async () => {
      go.disabled = true;
      prog.classList.remove('hidden');
      results.classList.add('hidden');
      imgs = [];
      tb = 0;
      tt = 0;

      try {
        for (let i = 0; i < files.length; i++) {
          upd(i, files.length, '🔍 Processando ' + (i + 1) + '/' + files.length);
          const r = await procCluster(files[i], i + 1);
          imgs.push(r);
        }
        upd(files.length, files.length, '✅ Concluído!');
        showRes();
      } catch (error) {
        console.error('Erro:', error);
        showErr('Erro: ' + error.message);
        go.disabled = false;
        prog.classList.add('hidden');
      }
    };

    async function procCluster(f, n) {
      return new Promise((res, rej) => {
        const r = new FileReader();
        r.onload = async e => {
          const img = new Image();
          img.onload = async () => {
            const c = document.createElement('canvas');
            const ctx = c.getContext('2d');
            c.width = img.width;
            c.height = img.height;
            ctx.drawImage(img, 0, 0);

            upd(null, null, '📝 OCR na imagem ' + n + '...');

            try {
              const ocr = await Tesseract.recognize(c, from.value, {
                logger: m => m.status === 'recognizing text' && upd(null, null, 'OCR: ' + Math.round(m.progress * 100) + '%')
              });

              const words = ocr.data.words.filter(w => 
                w.confidence > 45 && 
                w.text.trim().length >= 3 &&
                /[a-zA-ZÀ-ÿ]{2,}/.test(w.text)
              );

              console.log('Palavras válidas:', words.length);

              upd(null, null, '🧠 Agrupando palavras...');

              // CLUSTERING HIERÁRQUICO AGRESSIVO
              const clusters = hierarchicalCluster(words, 250); // Distância MUITO grande
              console.log('Clusters finais:', clusters.length);

              tb += clusters.length;

              for (let i = 0; i < clusters.length; i++) {
                const cluster = clusters[i];
                upd(null, null, '🌐 Traduzindo balão ' + (i + 1) + '/' + clusters.length + '...');

                // Ordenar palavras do cluster
                cluster.words.sort((a, b) => {
                  if (Math.abs(a.bbox.y0 - b.bbox.y0) > 20) return a.bbox.y0 - b.bbox.y0;
                  return a.bbox.x0 - b.bbox.x0;
                });

                const txt = cluster.words.map(w => w.text).join(' ');
                console.log('Texto:', txt);

                const trans = await translate(txt);
                tt++;

                drawBox(ctx, cluster.bbox, trans);
              }

              res(c.toDataURL('image/png', 0.95));
            } catch (e) {
              console.error('Erro OCR:', e);
              rej(new Error('Falha no OCR'));
            }
          };
          img.onerror = () => rej(new Error('Erro carregar'));
          img.src = e.target.result;
        };
        r.onerror = () => rej(new Error('Erro ler'));
        r.readAsDataURL(f);
      });
    }

    function hierarchicalCluster(words, maxDist) {
      if (words.length === 0) return [];

      // Criar clusters iniciais (cada palavra = 1 cluster)
      let clusters = words.map(w => ({
        words: [w],
        bbox: { x0: w.bbox.x0, y0: w.bbox.y0, x1: w.bbox.x1, y1: w.bbox.y1 }
      }));

      // Múltiplas passadas de merge
      let changed = true;
      let passCount = 0;
      const maxPasses = 10;

      while (changed && passCount < maxPasses) {
        changed = false;
        passCount++;

        for (let i = 0; i < clusters.length; i++) {
          for (let j = i + 1; j < clusters.length; j++) {
            const c1 = clusters[i];
            const c2 = clusters[j];

            // Calcular distância entre centros
            const cx1 = (c1.bbox.x0 + c1.bbox.x1) / 2;
            const cy1 = (c1.bbox.y0 + c1.bbox.y1) / 2;
            const cx2 = (c2.bbox.x0 + c2.bbox.x1) / 2;
            const cy2 = (c2.bbox.y0 + c2.bbox.y1) / 2;

            const dist = Math.sqrt((cx1 - cx2) ** 2 + (cy1 - cy2) ** 2);

            // Merge se próximos OU mesma linha/coluna
            const sameLine = Math.abs(cy1 - cy2) < 40;
            const sameCol = Math.abs(cx1 - cx2) < 40;

            if (dist < maxDist || sameLine || sameCol) {
              // Merge clusters
              c1.words.push(...c2.words);
              c1.bbox.x0 = Math.min(c1.bbox.x0, c2.bbox.x0);
              c1.bbox.y0 = Math.min(c1.bbox.y0, c2.bbox.y0);
              c1.bbox.x1 = Math.max(c1.bbox.x1, c2.bbox.x1);
              c1.bbox.y1 = Math.max(c1.bbox.y1, c2.bbox.y1);

              clusters.splice(j, 1);
              changed = true;
              break;
            }
          }
          if (changed) break;
        }
      }

      // Limitar a 5 balões maiores
      if (clusters.length > 5) {
        clusters.sort((a, b) => b.words.length - a.words.length);
        clusters = clusters.slice(0, 5);
      }

      return clusters;
    }

    function drawBox(ctx, bbox, txt) {
      const pad = 15;
      const x = bbox.x0 - pad;
      const y = bbox.y0 - pad;
      const w = bbox.x1 - bbox.x0 + pad * 2;
      const h = bbox.y1 - bbox.y0 + pad * 2;

      ctx.fillStyle = 'rgba(255, 255, 255, 0.98)';
      ctx.fillRect(x, y, w, h);

      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2.5;
      ctx.strokeRect(x, y, w, h);

      ctx.fillStyle = '#000';
      const fs = Math.max(Math.min(h * 0.3, 20), 13);
      ctx.font = 'bold ' + fs + 'px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      const words = txt.split(' ');
      const lines = [];
      let line = '';

      words.forEach(word => {
        const test = line + (line ? ' ' : '') + word;
        if (ctx.measureText(test).width > w - 30 && line) {
          lines.push(line);
          line = word;
        } else {
          line = test;
        }
      });
      if (line) lines.push(line);

      const lh = fs * 1.3;
      const sy = y + h / 2 - (lines.length * lh) / 2 + fs / 2;

      lines.forEach((l, i) => {
        ctx.fillText(l, x + w / 2, sy + i * lh);
      });
    }

    async function translate(txt) {
      if (!txt || txt.trim().length === 0) return txt;
      const fromLang = getLang(from.value);
      const toLang = to.value;

      try {
        const url = 'https://api.mymemory.translated.net/get?q=' + encodeURIComponent(txt) + '&langpair=' + fromLang + '|' + toLang;
        const response = await fetch(url);
        const data = await response.json();
        if (data.responseStatus === 200 && data.responseData.translatedText) {
          return data.responseData.translatedText;
        }
      } catch (e) {}

      return txt;
    }

    function getLang(code) {
      const map = { 'eng': 'en', 'por': 'pt', 'spa': 'es' };
      return map[code] || code;
    }

    function upd(cur, tot, msg) {
      if (cur !== null && tot !== null) fill.style.width = (cur / tot) * 100 + '%';
      text.textContent = msg;
    }

    function showRes() {
      results.classList.remove('hidden');
      out.innerHTML = '';
      sb.textContent = tb;
      st.textContent = tt;
      si.textContent = imgs.length;
      imgs.forEach(src => {
        const img = document.createElement('img');
        img.src = src;
        img.className = 'result-img';
        out.appendChild(img);
      });
      prog.classList.add('hidden');
      prev.classList.add('hidden');
      go.disabled = false;
    }

    function showErr(m) {
      err.textContent = '❌ ' + m;
      err.classList.remove('hidden');
    }

    function hideErr() {
      err.classList.add('hidden');
    }

    dl.onclick = () => {
      imgs.forEach((src, i) => {
        const a = document.createElement('a');
        a.href = src;
        a.download = 'manga-' + (i + 1) + '.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      });
    };

    newBtn.onclick = () => location.reload();

    console.log('🧠 V5.1 - Clustering hierárquico ativado!');
  </script>
</body>
</html>
